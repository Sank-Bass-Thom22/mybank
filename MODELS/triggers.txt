Juan Sorroche 
 
MySQL : Les Triggers
Un trigger, comme son nom l‚Äôindique, d√©clenche automatiquement une action √† la suite d‚Äôune requ√™te effectu√©e sur une table.
Afin d‚Äôillustrer l‚Äôutilisation de triggers, je vais partir d‚Äôun exemple simple : la mise √† jour simultan√©e de tables de deux bases de donn√©es pr√©sentes sur un serveur MySQL.
Sur mon serveur de base de donn√©es MySQL, j‚Äôai deux bases : bdd1 et bdd2. Dans chacune de ces deux bases, j‚Äôai une table ville qui contient la liste des villes de France et de leurs coordonn√©es g√©ographiques : Id, Nom, Code postal, Latitude et Longitude.
Par soucis de simplicit√© et d‚Äôefficacit√©, je souhaite que chaque insertion, mise √† jour ou suppression effectu√©es dans la table ville de bdd1 soient automatiquement impact√©es sur la table ville de bdd2. C‚Äôest ici que les triggers entrent en jeu.
Pour plus d‚Äôinformations quant √† la syntaxe des triggers, je vous invite √† lire la documentation : https://dev.mysql.com/doc/refman/5.7/en/trigger-syntax.html
Apr√®s un INSERT INTO (AFTER INSERT)
DROP TRIGGER IF EXISTS `bdd1`.`ville_AFTER_INSERT`;

DELIMITER $$
USE `bdd1`$$

CREATE DEFINER=`user`@`server` TRIGGER `bdd1`.`ville_AFTER_INSERT` AFTER INSERT ON `ville` FOR EACH ROW
BEGIN
INSERT INTO `bdd2`.`ville` (`id_ville`, `ville_nom`, `ville_cp`, `ville_lat`, `ville_lon`) SELECT NEW.`id_ville`, NEW.`ville_nom`, NEW.`ville_cp`, NEW.`ville_lat`, NEW.`ville_lon`;

END$$
DELIMITER ;
Copy
Apr√®s un UPDATE (AFTER UPDATE)
DROP TRIGGER IF EXISTS `bdd1`.`ville_AFTER_UPDATE`;

DELIMITER $$
USE `bdd1`$$

CREATE DEFINER=`user`@`server` TRIGGER `bdd1`.`ville_AFTER_UPDATE` AFTER UPDATE ON `ville` FOR EACH ROW
BEGIN
UPDATE `bdd2`.`ville` SET `ville_nom` = NEW.`ville_nom`, `ville_cp` = NEW.`ville_cp`, `ville_lat` = NEW.`ville_lat`, `ville_lon` = NEW.`ville_lon` WHERE `id_ville` = NEW.`id_ville`;

END$$
DELIMITER ;
Copy
Apr√®s un DELETE (AFTER DELETE)
DROP TRIGGER IF EXISTS `bdd1`.`ville_AFTER_DELETE`;

DELIMITER $$
USE `bdd1`$$

CREATE DEFINER=`user`@`server` TRIGGER `bdd1`.`ville_AFTER_DELETE` AFTER DELETE ON `ville` FOR EACH ROW
BEGIN
DELETE FROM `bdd2`.`ville` WHERE `id_ville` = OLD.`id_ville`;

END$$
DELIMITER ;
Copy
Et le tour est jou√© ! üôÇ D√©sormais, je n‚Äôai plus qu‚Äôune seule des deux tables ville √† administrer (celle de bdd1). La table de bdd2 sera automatiquement mise √† jour gr√¢ce √† ces triggers.
N.B. : Si vous faites un dump de vos bases mais que vous ne souhaitez pas inclure les triggers, pensez √† ajouter le param√®tre --skip-triggers √† votre commande.
